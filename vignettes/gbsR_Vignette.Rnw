
\documentclass{article}

\usepackage{natbib}
\usepackage{graphics}
\usepackage{amsmath}
\usepackage{indentfirst}
\usepackage[utf8]{inputenc}
\usepackage{color}
\usepackage{hyperref}

% \VignetteIndexEntry{gbsR_Example}

\begin{document}
\SweaveOpts{concordance=TRUE}

\title{gbsR: an R package to analyse Genotyping by Sequencing (GBS) data}
\author{Benjamin Mayne}
\maketitle

\tableofcontents

\clearpage

\section{Introduction}

Current GBS data analysis tools do not fulfill all experimental designs. For example, genotyping by sequencing (GBS) experiments using methylation sensitive restriction enzyme (REs) are an effective method to identify differentially methylated sites that may not be accessible in other technologies such as microarrays and capture sequencing. However, current data analysis tools do not satisfy the requirements for these types of experimental designs.

Here we present gbsR, an R package for data analysis of GBS experiments. Read counts and cut sites from a GBS experiment can be read directly into the R environment directly from a sorted and indexed BAM file(s).

\section{Third party tools}

The gbsR package functions within the R environment, however it requires the use of bedtools within your default PATH. gbsR can still function without bedtools, however to gain full value of the R package it is recommended that bedtools is installed. Bedtools can be installed from here: https://github.com/arq5x/bedtools2.

\section{Reading data into R}

The analysis with gbsR begins with a directory which contains sorted and indexed BAM files. gbsR contains an example data set containing 4 samples from a GBS experiment using the restriction enzyme ApeKI. In this example the 4 samples are from Barley and have be truncated for chromosome 1.

To read in the data directly into R can be done using the rawCounts() function, which requires the directory path to where the sorted and indexed files are located and the desired number of threads to be run (Default = 1).
<<load the example data>>=
library(gbsR)

my_path <- system.file("extdata", "sample1.bam", package = 'gbsR')
my_path <- gsub('sample1.bam', '', my_path)

datCounts <- rawCounts(bamFilepath = my_path, threads = 1)
@
The result is a data frame object containing a table of read counts. The columns are samples and the rows contain the location of each unique cut sites. Each cut site as been given a unique ID (chromosome:strand:position).

\section{Confirmation of correct cut sites}
After the table of read counts has been generated into the R environment, the next step would be to confirm that the cut sites are the correct cut sites that would have been generated by the restriction enzyme. In this example, the restriction enzyme that has been used is ApeKI which recognizes a 5bp sequence (GCWGC, where W is A or T).

To load the path to the fasta file:
<<load the path to the fasta file>>=
chr1 <- system.file("extdata", "chr1.fa", package = 'gbsR')
@

The next step is to extract the location of cut sites from datCounts and adjust the cut sites such that the region will cover the recognition sequence of ApeKI.
<<extract cut sites>>=
x <- data.frame(row.names(datCounts))
x <- data.frame(t(data.frame(strsplit(x=as.character(x[,1]), split=':'))))

x[,2] <- x[,3]
x <- as.matrix(x)
row.names(x) <- NULL
x[,3] <- as.numeric(x[,3]) +3
x[,2] <- as.numeric(x[,2]) -2
x <- as.matrix(x)
@

The object x is a matrix that contains the chromosome ID, the start and end position of the ApeKI sequence length around the cut sites. These cut sites can now be checked if the sequence matches the ApeKI sequence (GCAGC or GCTGC).

To determine which cut sites correctly match the ApeKI sequence:
<<run checkCuts>>=
x1 <- checkCuts(cutSites = x, cutIDs = row.names(datCounts),
      fastaPath = chr1, seq = 'GCAGC', chr.prefix = FALSE)
x2 <- checkCuts(cutSites = x, cutIDs = row.names(datCounts),
      fastaPath = chr1, seq = 'GCTGC', chr.prefix = FALSE)
@

The x1 and x2 object now contain the correct cut site locations of ApeKI that were generated from this experiment.
The correct ApeKI cut sites can be filtered out of datCounts:
<<filter out incorrect cuts>>=
cuts <- rbind(x1, x2)
datCounts <- datCounts[match(cuts$ID, row.names(datCounts)), ]
datCounts <- datCounts[unique(row.names(datCounts)),]
@

datCounts now contains the correct cut sites and now be used in downstream analyses

\section{Visualization of read counts}

Before further downstream analyses with the table of read counts, the user may want to filter out samples that did no generate a sufficient amount of read counts or low cut sites. The gbsR package contains a function which plots the total number of read counts against the total number of cut sites produced per sample.

To visualize the total number of read counts against the total number of cut sites produced per sample:
<<plot counts per cut sites >>=
plotCounts(countMatrix = datCounts, condition1 = colnames(datCounts))
@
This function generates a plot (Figure 1) where the x axis and y axis represents the total number of reads and the total number of cut sites produced for each sample respectively.

\setkeys{Gin}{width=1\linewidth}
\begin{figure}
\begin{center}
<<label=fig1, fig=TRUE, echo=FALSE, eps=FALSE, >>=
plotCounts(countMatrix = datCounts, condition1 = colnames(datCounts))
@
\end{center}
\caption{Variation of the total number of reads and cut sites produced in each sample.}
\label{fig:fig1}
\end{figure}

\clearpage


\section{Differential cutting analysis}
gbsR utilizes edgeR in order to determine which cut sites are differentially cut between groups. Since many GBS experiment can have many samples and groups gbsR offers a wrapper function of edgeR functions to automate differential cutting analysis.
To determine which cut sites are differentiallly cut between groups:
<<differential cutting>>=
y <- data.frame(c('GpA', 'GpA', 'GpB', 'GpB'))
colnames(y) <- 'Group'
top <- diffCutting(countMatrix = datCounts, pd = y, cateogory = 'Group',
                   condition1 = 'GpA', condition2 = 'GpB', block = NULL,
                   cpmThreshold = 1, thresholdSamples = 2)
@

The top object now contains a data frame of the cut sites that had a CPM > 1 in at least 2 samples and which cut sites are differentially cut between the two groups.

\section{Visualization of cut site locations}
The gbsR package contains 2 functions to allow visualization of the location of cut sites. Given the lengths of the chromosomes the cut sites can be visualized in a circos plot (Figure 2) or a karyogram (Figure 3). For example, differentially cut sites can be visualized in a circos plot or a karyogram.

Firstly, define the length of the chromosome.
<<chr1 length>>=
chr1 <- matrix(c('chr1', '464124043'), nrow = 1, ncol = 2)
@
Extract the top 100 most differentially expressed cut sites.
<<top sites>>=
z <- top$cut_site[1:100]
z <- data.frame(t(data.frame(strsplit(x=as.character(z), split=':'))))
z <- as.matrix(z)
row.names(z) <- NULL
@
To generate a circos plot:
<<circos plot>>=
plotCircos(cutSites = z[,c(1,3,3)], genome = chr1,
           cutSite.colour = 'red', genome.colour = 'blue')
@
To generate a karogram plot:
<<karyogram plot>>=
plotChr(cutSites = z[,c(1,3,3)], genome = chr1)
@


\setkeys{Gin}{width=1\linewidth}
\begin{figure}
\begin{center}
<<label=fig2, fig=TRUE, echo=FALSE, eps=FALSE, >>=
plotCircos(cutSites = z[,c(1,3,3)], genome = chr1,
           cutSite.colour = 'red', genome.colour = 'blue')
@
\end{center}
\caption{A circos plot representing the top 100 differential cut sites.}
\label{fig:fig2}
\end{figure}

\clearpage


\setkeys{Gin}{width=1\linewidth}
\begin{figure}
\begin{center}
<<label=fig3, fig=TRUE, echo=FALSE, eps=FALSE, >>=
plotChr(cutSites = z[,c(1,3,3)], genome = chr1)
@
\end{center}
\caption{A karyogram of chromosome 1 showing the location of differential cut sites.}
\label{fig:fig3}
\end{figure}

\clearpage

\section{Annotation}
The gbsR package can also work with gff files to annotate interesting positions such as those that might be differentially methylated. Annotation can be done using the closestFeat function which requires 3 inputs of information. Annotation can also be strand specific.

Firstly, define the length of the chromosome.
<<annotation>>=
mygff <- system.file("extdata", "chr1.gff3", package = 'gbsR')
features <- closestFeat(gff = mygff, positions = z[1:100,], strand.specific = FALSE)
head(features)
@


\end{document}
